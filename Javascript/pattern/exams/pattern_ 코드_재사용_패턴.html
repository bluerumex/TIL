<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>코드 재사용 패턴</title>
</head>
<body>
<script>
    // -------------------- 6. 코드 재사용 패턴 -------------------- //

    // 코드 재사용에 있어 가장 먼저 떠오르는 건 상속이다.
    // 클래스 방식의 상속과 그렇지 않은 상속 몇 가지를 살펴 볼 것 이다.
    // 상속은 목표에 이르는 하나의 방법(수단)이지 유일한 방법은 아니다
    // 1) 다른 객체와 합성하는 방법
    // 2) 믹스-인 객체를 사용하는 방법
    // 3) 기술적으로는 어떤 것도 영구히 상속하지 않으면서 필요한 기능만 빌려오는 방법

    // -------------------- 6.1 클래스 방식 vs. 새로운 방식의 상속 패턴 -------------------- //

    // 대다수의 프로그래밍 언어는 객체의 설계도로 클래스라는 개념을 가지고 있다
    // 자바와 같은 언어들에서는 모든 객체가 어떤 클래스의 인스턴스이며, 클래스 없이는 객체를 생성할 수 없다
    // 자바스크립트에는 클래스가 없기 때문에 클래스의 인스턴스라는 개념도 잘 들어맞지 않는다.

    // 자바스크립트의 객체는 단순히 키-값의 쌍들일뿐이며 언제든지 생성하고 변경할 수 있다.

    // 자바 클래스 생성
    // Person adam = new Person();

    // 자바스크립트
    // var adam = new Person();

    // 자바스크립트의 생성자 호출을 보면 Person이 클래스인것 같지만, Person이 여전히 보통의 함수라는 사실을
    // 잊지 말아야 한다.
    // 문법의 유사성 때문에많은 개발자들이 자바스크립트를 클래스 관점에서 생각하고 클래스를 전제한 상속
    // 패턴을 발전시켜 왔다. 이러한 구현 방법을 '클래스 방식'이라고 부를 수 있다.

    // -------------------- 6.2 클래스 방식의 상속을 사용할 경우 예상되는 산출물 -------------------- //

    // 클래스 방식의 상속을 구현할 때의 목표는 Child()라는 생성자 함수로 생성된 객체들이
    // 다른 생성자 함수인 Parent()의 프로퍼티를 가지도록 하는 것이다

    // 부모 생성자
    function Parent(name) {
        this.name = name || 'Adam';
    }

    // 생성자의 프로토타입에 기능을 추가한다
    Parent.prototype.say = function() {
        return this.name;
    }

    // 아무 내용이 없는 자식 생성자
    function Child(name) {}

    // 여기서 상속 (구현 해야됨)
    inherit(Child, Parent);

    // -------------------- 6.3 클래스 방식의 상속 패턴#1 - 기본 패턴 -------------------- //

    // 가장 널리 쓰이는 방식으로 Parent() 생성자를 사용해 객체를 생성한 다음,
    // 이 객체를 Child()의 프로토타입에 할당하는 것

    // inherit 구현의 첫 번째 예젠
    function inherit(C, P) {
        C.prototype = new P();
    }

    // kid 객체에 name 프로퍼티를 생성하게 된다
    var kid = new Child();
    kid.name = "Patrick";
    kid.say(); // "Patrick"

    // 패턴#1의 단점
    // 부모 객체의 this에 추가된 객체 자신의 프로퍼티와 프로토타입 프로퍼티를 모두 물려받게 된다는 점이다.
    // 대부분의 경우 객체 자신의 프로퍼티는 특정 인스턴스에 한정되어 재사용할 수 없기 때문에 필요가 없다.

    // *재사용 가능한 멤버는 프로토타입에 추가해야 한다는 것이 구성 요소를 만드는 일반 원칙이다

    // 범용 inherit() 함수는 인자를 처리하지 못하는 문제도 가지고 있다.
    // 즉 자식 생성자에 인자를 넘겨도 부모 생성자에게 전달하지 못한다.

    // var s = new Child('Seth');
    // s.say(); // "Adam"

    // 자식 객체가 부모 생성자에 인자를 전달하는 방법도 있겠지만, 이 방법은 자식 인스턴스를 생성할 때마다
    // 상속을 실행해야 하기 때문에, 결국 부모 객체를 계속해서 재생성 하는 셈이고, 따라서 매우 비효율 적이다.

    // -------------------- 6.4 클래스 방식의 상속 패턴#2 - 생성자 빌려쓰기 -------------------- //

    // 자식에서 부모로 인자를 전달하지 못했던 패턴#1의 문제를 해결한다
    // 이 패턴은 부모 생성자 함수의 this에 자식 객체를 바인딩한 다음, 자식 생성자가 받은 인자들을 모두 넘겨준다

    function Child2(a, b, c, d) {
        Parent.apply(this, arguments);
    }




</script>
</body>
</html>