<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>객체 생성 패턴</title>
</head>
<body>
<script>
    // -------------------- 5.1 네임스페이스 패턴 -------------------- //


    // 수정 전: 전역 변수 5개.
    // anti pattern

    // 생성자 함수 2개
    function Parent() {}
    function Child() {}

    // 변수 1개
    var some_var = 1;

    // 객체 2개
    var module = {};
    module.data = {a: 1, b: 2};
    var module2 = {};

    // - 위의 코드를 리펙토링 하기 위해 먼저 애플리케이션용 전용 전역 객체,
    // - 이를 테면 MYAPP 을 생성한다. 그런 다음 함수와 변수를 전역 객체에 프로퍼티로 변경

    // 수정 후 : 전역 변수 1개

    // 전역객체
    var MYAPP = {};

    // 생성자
    MYAPP.Parent = function() {};
    MYAPP.Child = function () {};

    // 변수
    MYAPP.some_var = 1 ;

    // 객체 컨테이너
    MYAPP.modules = {};

    // 객체들을 컨테이너 안에 추가한다.
    MYAPP.modules.module1 = {};
    MYAPP.modules.module1.data  = {a: 1, b:2};
    MYAPP.modules.module2 = {};

    // ---------- 범용 네임스페이스 함수

    // 범용 네임스페이스 함수를 생성하거나 프러퍼티를 추가하기 전에 먼저 이미 존재하는지 여부를
    // 확인하는 것이 최선이다.

    // 위험
    var MYAPP = {};
    // 개선안
    if (typeof MYAPP === "undefined") {
        var MYAPP = {};
    }
    // 더 짧게..
    var MYAPP = MYAPP || {};

    // 네임스페이스 생성 함수

    var MYAPP = MYAPP || {};

    MYAPP.namespace = function (ns_string) {
        var parts = ns_string.split('.'),
            parent = MYAPP,
            i;

        // 처음에 중복되는 전역 객체명은 제거한다
        if (parts[0] === "MYAPP") {
            parts = parts.slice(1);
        }

        for (i = 0; i < parts.length; i += 1) {
            // 프로퍼티가 존재하지 않으면 생성한다.
            if (typeof parent[parts[i]] === "undefined") {
                parent[parts[i]] = {};
            }

            parent = parent[parts[i]];
        }
        return parent;
    };

    // 반환값을 지역 변수에 할당
    var module2 = MYAPP.namespace('MYAPP.modules.module2');
    module2 === MYAPP.modules.module2; // true

    // 첫부분의 'MYAPP'을 생략하고도 쓸수 있다
    MYAPP.namespace('modules.module51');


    // -------------------- 5.2 의존관계 선언-------------------- //


    // 자바스크립트 라이브러리들은 대게 네임스페이스를 지정하여 모듈화되어 있기 때문에,
    // 필요한 모듈만 골라서 사용할 수 있다
    // 예를 들어 YUI2에는 네임스페이스 역할을 하는 YAHOO라는 전역 변수가 있고,
    // 이 전역 변수의 프로퍼티로 YAHOO.util.DOM이나 YAHOO.util.Event와 같은 모듈이 추가되어 있다

    // 함수나 모듈 내 최상단에, 의존 관계에 있는 모듈을 선언하는 것이 좋다
    // 지역변수를 만들어 원하는 모듈을 가리키도록 선언
    var myFunction = function() {
        // 의존 관계에 있는 모듈들
        var event = YAHOO.util.Event,
            dom = YAHOO.util.DOM;

        // 이제 event오 dom이라는 변수를 사용 한다
    };


    // -------------------- 5.3 비공개 프로퍼티와 메서드 -------------------- //

    // 자바 등 다른 언어와 달리 자바스크립트에는 private, protected, public 프로퍼티와 메서드를
    // 나타내는 별도의 문법이 없다. 객체의 모든 멤버는 public이다

    var myobj = {
        myprop: 1,
        getProp: function() {
            return this.myprop;
        }
    };

    // 공개 접근 가능
    console.log(myobj.myprop);
    console.log(myobj.getProp());

    // 생성자 함수를 사용해 객체를 생성할 대도 마찬가지로 모든 멤버가 공개

    function Gadget() {
        this.name = 'iPod';
        this.strech = function() {
            return 'iPad';
        };
    }

    var toy = new Gadget();
    console.log(toy.name);
    console.log(toy.strech());

    // ---------- 비공개(private) 멤버
    // 비공개 멤버에 대한 별도의 문법은 없지만 클로저를 사용해 구현할 수 있다

    function privateGadGet() {
        // 비공개 멤버
        var name = "iPod";
        this.getName = function() {
            return name;
        }
    }

    // ---------- 특권(privileged) 메서드
    // 특권 메서드라는 개념은 특정한 문법과 관련이 없다.
    // 단지 비공개 멤버에 접근권한을 가진 (즉 일종의 특권을 부여받은) 공개 메서드를 가리키는 이름일 뿐이다

    // 비공개 멤버의 허점
    function privilegedGadget() {
        // 비공개 멤버
        var specs = {
            screen_width: 320,
            screen_height: 480,
            color: 'white'
        }

        // 공개 함수
        this.getSpecs = function () {
            // 여기서 getSpec 메서드가 spec객체의 참조를 반환한다는게 문제
            return specs;
        }
    }

    var toy2 = new privilegedGadget(),
        specs = toy.getSpecs();

    // specs는 감춰진 비공개 멤버처럼 보이지만, Gadget 사용자에 의해 변경될 소지가 있다
    specs.color = "black";
    specs.price = "free";
    console.dir(toy2.getSpecs());








</script>
</body>
</html>