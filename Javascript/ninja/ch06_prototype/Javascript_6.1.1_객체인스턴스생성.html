<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="../scripts/assert.js"></script>
    <link href="../styles/assert.css" rel="stylesheet" type="text/css">
</head>
<body>
<script>
    // 모든 하수에는 prototype 프로퍼티가 있고 이 prototype 프로퍼티는 처음에는 빈 객체를 참조한다.
    // 만약 함수를 생성자로 사용하지 않는다면 이 prototype 프로퍼티는 그다지 쓸모가 없다.

    // 6.1.1 객체 인스턴스 생성
    // 새로운 객체를 만드는가장 간단한 방법은 다음과 같다.
    var o = {};

    // 새로운 빈 객체를 생성하고, 할당 구문을 통해 프로퍼티를 덧 붙였다.
    var o = {};
    o.name = 'saito';
    o.occupation = 'sniper';
    o.cyberizationLeve = 20;

    // 객체 지향에 익숙한 사람은 위 코드에 캡슐화, 클래스 생성자 개념같은 어떠한 객체 지향 구조도
    // 없다는 것을 눈치 챘을 것이다. (생성자는 객체를 우리가 알고 있는 어떤 상태로 초기화하는 역할을 하는 함수다)
    // 결국 같은 타입의 객체에 대해 여러 인스턴스를 생성해야 한다면, 매번 개별적으로 프로퍼티를 할당해야한다.

    // *객체 청사진으로서의 프로토타입
    function Ninja() {};

    Ninja.prototype.swingSword = function() {
        return true;
    }

    // 함수를 일반적인 방식으로 호출하고 그 결과를 ninja1 변수에 저장
    // 함수 본문에 반환값이 없기 때문에 undefined 일것이다.
    var ninja1 = Ninja();
    assert(ninja1 === undefined, 'Ninja 인스턴스가 만들어지지 않았다.');

    // new 연산자를 사용하여 생성자로 함수를 호출하면 완전히 다른 일이 일어난다. 다시 한번 Ninja() 함수가 호출되지만,
    // 이번에는 새로운 객체가 함ㅅ의 콘텍스트로 설정된다.
    // new 연산자의 반환값은 새로운 객체를 참조한다.
    var ninja2 = new Ninja();
    assert(ninja2 && ninja2.swingSword && ninja2.swingSword(), '인스턴스가 존재하고 메서드도 호출할 수 있다');

    // *인스턴스 프로퍼티
    // new 연산자를 사용하여 함수를 생성자로 호출하면, 새로 생성된 객체 인스턴스가 함수의 컨텍스트로 설정된다.
</script>
</body>
</html>